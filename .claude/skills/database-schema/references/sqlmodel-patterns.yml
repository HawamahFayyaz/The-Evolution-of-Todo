# SQLModel Pattern Reference

base_model:
  description: "Base class with audit fields (inherit from this)"
  example: |
    class BaseModel(SQLModel):
        id: Optional[int] = Field(default=None, primary_key=True)
        created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
        updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
        deleted_at: Optional[datetime] = Field(default=None, index=True)

table_model:
  description: "Inherit from BaseModel and set table=True"
  example: |
    class User(BaseModel, table=True):
        __tablename__ = "users"
        email: str = Field(max_length=255, unique=True, index=True)
        name: str = Field(max_length=100)

foreign_key:
  description: "Always add index=True to foreign keys"
  example: |
    user_id: int = Field(foreign_key="users.id", index=True)

relationship_one_to_many:
  description: "User has many Tasks"
  example: |
    # In User model
    tasks: list["Task"] = Relationship(back_populates="user")

    # In Task model
    user_id: int = Field(foreign_key="users.id", index=True)
    user: User = Relationship(back_populates="tasks")

relationship_many_to_many:
  description: "Tasks have many Tags (via junction table)"
  example: |
    # Task model
    tags: list["Tag"] = Relationship(back_populates="tasks", link_model="TaskTag")

    # Tag model
    tasks: list[Task] = Relationship(back_populates="tags", link_model="TaskTag")

    # Junction table
    class TaskTag(BaseModel, table=True):
        task_id: int = Field(foreign_key="tasks.id", primary_key=True, index=True)
        tag_id: int = Field(foreign_key="tags.id", primary_key=True, index=True)

soft_delete:
  description: "Never hard delete - set deleted_at instead"
  example: |
    def soft_delete(task_id: int, session: Session):
        task = session.get(Task, task_id)
        task.deleted_at = datetime.now(timezone.utc)
        task.updated_at = datetime.now(timezone.utc)
        session.commit()

    def get_active_tasks(session: Session):
        return session.exec(
            select(Task).where(Task.deleted_at.is_(None))
        ).all()

composite_index:
  description: "Index multiple columns together for query performance"
  example: |
    from sqlalchemy import Index

    class Message(BaseModel, table=True):
        conversation_id: int = Field(foreign_key="conversations.id", index=True)
        created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

        __table_args__ = (
            Index("idx_conversation_created", "conversation_id", "created_at"),
        )

neon_database_setup:
  description: "Neon Serverless PostgreSQL connection with NullPool"
  example: |
    from sqlmodel import create_engine
    from sqlalchemy.pool import NullPool

    DATABASE_URL = "postgresql://user:pass@host.neon.tech/db?sslmode=require"

    engine = create_engine(
        DATABASE_URL,
        echo=False,
        poolclass=NullPool  # Required for serverless environments
    )

field_constraints:
  description: "Add validation constraints to fields"
  examples:
    string_length: "title: str = Field(max_length=200, min_length=1)"
    numeric_range: "priority: int = Field(ge=1, le=5)"
    unique: "email: str = Field(unique=True, index=True)"
    default_value: "completed: bool = Field(default=False)"
    nullable: "description: Optional[str] = Field(default=None)"
